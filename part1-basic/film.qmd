# Film {#sec-film}

Imagine you're taking a photo with your phone. Light from your environment come into the camera, across a bunch of lens, and finally hit the sensor - that's what we're going to do in this chapter, where the rendering result of our renderer will be stored!

## Film Abstraction

The film is where we'll store the intermidiate state when rendering, and it will be converted to the final image to be saved as output.

So the film should has the same size as the output we expect. There should also be a method to convert it into the result image. And by that way, we should be allowed to access each pixel by a 2D index, as well as updating the pixels by its index.

An important part of this film abstraction is the ability to be splitted into a lot of tiles, and we can then process and render into the film tile by tile, concurrently. To simplify, we will constraint that the tile size should fit the film evenly, otherwise you could just throw remainging pixels away, or do whatever you choose to do. We should also avoid copying tile data everywhere when we need to process the film in tiled-based way, so a view-based tile representation is also needed to avoid too much memory allocation and copy.

::: callout-caution
## Demostrate the Tiled Film

Add a figure here to show how the film could be tiled.
:::

## Implementation Choice

### 2D Array - `ndarray`

We'll leave the implmentation to others, and use the `ndarray` crate for this film struct. There're mainly two way to create a new type based on another type:

-   Wrapper Pattern
-   Type Alias

The one I choose here is type alias. In this way, we can use methods provided by the `ndarray` crate naturally without the ugly `.0` infix, or spend much time on delegating methods to the inner type. However, there're also a lot problems with this approach. First the type inference rule won't use this alias for the type. Second, it's a problem that people can pass a wrong instance with the same type to our methods - we lost a great benefit of type-driven design! See [Exercise @sec-p1c3-qcfp-wrapper].

### Output Image

## Implementation

Just like how we've implemented additional methods for the `Color` type, we can do the same thing for this `Film` type. We've also given an alias name to the `Color` type for convienience:

``` rust
// color.rs
pub type Color = palette::LinSrgb<f32>;

// film.rs
pub type Film = Array2<Color>;
pub type OutputImage = ImageBuffer<Rgb<u8>, Vec<u8>>;

pub trait FilmExt {
    fn to_output(&self) -> OutputImage;
}

impl FilmExt for Film {
    fn to_output(&self) -> OutputImage {
        OutputImage::from_fn( // <1>
            self.dim().0 as u32,
            self.dim().1 as u32,
            |x, y| self[(x as usize, y as usize)].to_output_color(),
        )
    }
}
```

1.  `from_fn` is a method provided by the `image` crate, which can be used to create an image from a function. Here's we're copying data from the array to the image, pixel by pixel. You can also try `from_par_fn`, since we'll use `rayon` for parallel rendering, and the `image` crate has this method to improve this performance.

Write a unit test for it like what we've done in the last chapter. A tip: use a simple film, like $3 \times 3$ size film to test this.

Next, we'll add the functionality of tiled-based parallel processing to it. Thanks to `ndarray` and `rayon`, this is extremely easy, especially we have the constraint that the tile size should fit the film size evenly. Enable parallel processing functionality of `ndarray` by adding the `rayon` feature to `ndarray` in your `Cargo.toml`, and add `rayon` as another dependency if you haven't, we'll use it many times later.

``` toml
ndarray = { version = "0.15.6", features = ["default", "rayon"] }
rayon = "1.10.0"
```

Now let's add the tiles. `ndarray` provides a method called `exact_chunks`, which can be used to split an array into a bunch of tiles as we've stated. We also eed to calculate the position of each tile, which are indexed in a row major manner.

``` Rust
pub type FilmTileMut<'a> = ArrayViewMut<'a, Color, Ix2>;

pub trait FilmExt {
    // ...
    
    fn whole_tile<F>(&mut self, f: F) // <1>
    where
        F: Fn(FilmTileMut<'_>) + Send + Sync;
    
    fn tile_based<F>(&mut self, tile_size: (usize, usize), f: F)
    where
        F: Fn((usize, usize), FilmTileMut<'_>);

    fn tile_based_parallel<F>(&mut self, tile_size: (usize, usize), f: F)
    where
        F: Fn((usize, usize), FilmTileMut<'_>) + Send + Sync;
}

impl FilmExt for Film {
    // ...

    fn whole_tile<F>(&mut self, f: F)
    where
        F: Fn(FilmTileMut<'_>) + Send + Sync,
    {
        f(self.view_mut())
    }

    fn tile_based<F>(&mut self, (x, y): (usize, usize), f: F)
    where
        F: Fn((usize, usize), FilmTileMut<'_>),
    {
        let w = self.shape()[1] / x;
        self.exact_chunks_mut((x, y)) // <2>
            .into_iter()
            .enumerate()
            .for_each(|(index, tile)| f((index / w * x, index % w * y), tile));
    }

    fn tile_based_parallel<F>(&mut self, (x, y): (usize, usize), f: F) // <3>
    where
        F: Fn((usize, usize), FilmTileMut<'_>) + Send + Sync,
    {
        let w = self.shape()[1] / x;
        self.exact_chunks_mut((x, y))
            .into_iter()
            .enumerate()
            .par_bridge()
            .for_each(|(index, tile)| f((index / w * x, index % w * y), tile));
    }
}
```
1. To treat the tiled and un-tiled version in the same way, we also add a `whole_tile` method which provides similiar interfce as the tiled version.
2. Note that we're using `exact_chunks_mut` as stated above since we need the mutability. And we provided two similiar version of tiling, i.e., one uses `rayon` to calculate parallelly, and the other just executes one by one.
3. If we follow the common naming convention in the `Rust` community, the name here should be `tile_based_parallel_mut`. However, this might be too long, and almost every time we call this method, we would modify the original array, so we can eliminate the `_mut` suffix as well as the immutable version here.

Based on the test above, write another version for this and test the correctness of this parallel version. If you used some I/O or time-wasting code, you can add `#[ignore]` to the test and run it only when you want.

## Questions, Challenges & Future Possibilities {#sec-p1c3-qcfp}

### Wrapper Pattern for Film Implementation {#sec-p1c3-qcfp-wrapper}

As we've mentioned previously, the type alias approach leaves some problems. Try to re-implement it using the wrapper pattern. Provide some beatiful methods to access the methods originally provided by `ndarray`.

Wrapper pattern is widely used in `Rust` community. Think about is there any convient way to delegate methods to the inner type? Is there tools helping you to eliminate the ugly `.0` or the boilerplate? Try to search on `crates.io` or make your own one!