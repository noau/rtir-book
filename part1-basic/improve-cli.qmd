# Improve Cli I {#sec-improve-cli-i}

In this chapter, we'll temporarily move away from the rendering itself, and trying to improve our renderer in some way to make our developing experience better.

::: callout-note
## Language Specific Chapter

This chapter is language specific, which means we spend most time discussing `Rust` and its ecosystem. If you're not using `Rust`, this chapter is still useful, but you need more efforts to achieve the same effects I've done since I use lots of 3rd parties.

You can also skip but it's **not** recommended.
:::

## Improvements

### Cli Parameters {#sec-p1c5-cli-param}

As mentioned earlier in @sec-brute-rendering, we usually use cli parameter to change the behavior of our renderer. Let's first list all possible parameters:

- `tiling`: Use tiled rendering with given tile size.
- `parallel`: A flag enable `rayon`.
- `preview`: Enable real-time preview with `tev` image viewer opened. See @sec-p1c5-real-time-preview.
- `save`: Accepts a path that the rendered result will be save, or don't save if no path is given.

Above are parameters for the renderer.

- `spp`: This should be positive integer, or not presented to use the value defined for the scene.
- `max-ray-depth`: Also positive integer, or not presented to use the value defined for the scene.
- `diable-jittering`: Flag that disable pixel jittering. This means jittering is enabled by default.
- `orthographic`: Flag that enable orthographic projection for the camera. Otherwise projective projection will be used.
- `film-size`: The film size, which is also the output image size.

Above are parameters for to overwrite some parameters in the scene.

- `fast`: A short-hand flag that enables both `parallel` and `tiling`
- `fast-preview`: A short-hand flag that enables `parallel` and `tiling`, and set `spp` to `4`, `max-ray-depth` to `4` to obtains a very fast preview rendering.

Above are shorthands for convience.

All those are parameters for a command called `render`. So you use this cli just like hoe you use `git` - `<renderer-executable> render [parameters...]`. Later we'll add some other commands.

I'm going to use `clap` for cli parameter parsing, since it's powerful and matured.

If you haven't learned about `clap` yet, refer to the book, reference or cookbook of `clap`. What I'm using is called the `derive` api of `clap`, which can generate a argument parser automatically for our parameter definition. The parsed parameter is:

```Rust
#[derive(Parser)]
#[command(version = build::CLAP_LONG_VERSION, about, long_about = None)]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}
```

Note that the `build::CLAP_LONG_VERSION` requires the use of `shadow-rs`. When you use the `--version`(`-v`) option generated by `clap`, this information will be printed out. And the `about` will print out your doc comment for this struct, not just for this, struct, but almost all of them.

The use of `#[command(subcommand)]` means that our cpplication requires a subcommand, which is defined in the `Commands` struct:

```Rust
#[derive(Debug, Subcommand)]
pub enum Commands {
    Render {
        #[arg(
            short, long, name = "TILE_WIDTH,TILE_HEIGHT", value_parser = parse_non_zero_usize_pair // <1>
        )]
        tiling: Option<(usize, usize)>,
        #[arg(
            short, long, name = "FILM_WIDTH,FILM_HEIGHT", value_parser = parse_non_zero_usize_pair
        )]
        film_size: Option<(usize, usize)>,
        #[arg(short, long)]
        parallel: bool,
        #[arg(long)]
        save: Option<Option<PathBuf>>,
        #[arg(long)]
        disable_jittering: Option<bool>,
        #[arg(short, long)]
        orthographic: Option<bool>,
        #[arg(long)]
        preview: bool,
        #[arg(long)]
        spp: Option<NonZeroUsize>,
        #[arg(short = 'd', long)]
        max_ray_depth: Option<NonZeroUsize>,
        #[arg(long)]
        fast: bool,
        #[arg(long)]
        fast_preview: bool,
        sample_scene: SampleScene, // <2>
    },
}

fn parse_non_zero_usize_pair(s: &str) -> Result<(usize, usize), String> {
    let parts: Vec<&str> = s.split(',').collect();
    if parts.len() != 2 {
        return Err("Must be exactly two positive integers.".to_owned());
    }

    let size1 = parts[0]
        .trim()
        .parse::<usize>()
        .map_err(|_| "Must be positive integer.".to_owned())?;
    let size2 = parts[1]
        .trim()
        .parse::<usize>()
        .map_err(|_| "Must be positive integer.".to_owned())?;

    if size1 > 0 && size2 > 0 {
        return Ok((size1, size2));
    }

    Err("Must be positive integer.".to_owned())
}
```
1. The film size and tile size should be two positive integers, like `32,32`, which is a format `clap` doesn't support by default, so we need a custom parser to handle this.
2. Choice of the sample scene is a positional argument instead of an option.

To make things easier, we add a new struct to organize those parameters, and seperate parameters for overwrite scene settings into another struct. Those shorthands are also eliminated.

```Rust
#[derive(Debug, Clone)]
pub struct RenderingConfig {
    pub render_mode: RenderMode,
    pub preview: bool,
    pub test_scene: TestScene,
    pub save: Option<PathBuf>,
    pub scene_config: SceneConfig,
}
```

The conversion between `Commands` and `RenderingConfig` is quite straightforward but verbose, so I am just not showing them.

So now we can extract most part of our `main` to another function that accepts a `RenderingConfig`, instead, the main function parses the cli parameters and start rendering:

```Rust
fn main() {
    // Init the logger for outputs
    env_logger::init();

    let cli = Cli::parse();
    match cli.command {
        r @ Commands::Render { .. } => rendering(r.to_rendering_config()), // <1>
    }
}
```
1. This weird `@` bound value to r if matched.

And the `rendering` function is still similiar, just apply those parameters accordingly. The benefit of seperating parameters for the scene makes it easy to pass them to the scene loader, i.e., currently the `TestScene::build` function.

Try to add more useful argument by your own!

### Progress Report {#sec-p1c5-progress-bar}

Now we've already have a simple progress, but it works badly - the console quickly scrolls, and it's hard to see useful informations. It's not even a bar! We're going to use `indicatif` to add some nice progress bars.

Fisrt, instead of directly initialize the logger, we create the context of `indicatif`'s multiple progress bar, and init logger with it. This would be passed through our applicaiton so that whenever a progress bar is needed, the same progress context is used to support correct multiple progress bars. We also set the deault log level to `info` if `RUST_LOG` environment variable is not set.

```Rust
int main() {
    // Init the logger for outputs
    let progress_bar = MultiProgress::new();

    // recreate the logger
    let log_env = env_logger::Env::default().filter_or(env_logger::DEFAULT_FILTER_ENV, "info");
    let logger = env_logger::builder().parse_env(log_env).build();
    LogWrapper::new(progress_bar.clone(), logger)
        .try_init()
        .unwrap();
    
    // ...
}
```

Then at the place where we update the `film`, we can also update this progress bar accordingly.

```Rust
pub fn render(scene: Scene, render_mode: RenderMode, progress_bar: MultiProgress) -> Scene {
    // ...

    let tile_progress = render_mode.tiled.map(|(w, h)| { // <1>
        progress_bar.add(
            ProgressBar::new(((x / w) * (y / h)) as u64).with_style(
                ProgressStyle::default_bar()
                    .tick_strings(&["#", "##-", "-"])
                    .template(
                        "[{elapsed}] Tiles [{wide_bar:.green/cyan}] {percent}% ({pos}/{len}) <eta:{eta}>",
                    )
                    .unwrap_or(ProgressStyle::default_bar()).progress_chars("##-"),
            ),
        )
    });
    let pixel_progress = progress_bar.add(
        ProgressBar::new((x * y) as u64).with_style(
            ProgressStyle::default_bar()
                .template(
                    "[{elapsed}] Pixel [{wide_bar:.green/cyan}] {percent}% ({pos}/{len}) <eta:{eta}>",
                )
                .unwrap_or(ProgressStyle::default_bar())
                .progress_chars("##-"),
        ),
    );

    while !handle.is_finished() {
        if let Ok(message) = receiver.try_recv() {
            match message {
                RenderMessage::Pixel { position, color } => {
                    film[position] = color;
                    pixel_progress.inc(1);
                }
                RenderMessage::Tile { .. } => {
                    if let Some(tile_progress) = &tile_progress {
                        tile_progress.inc(1);
                    }
                }
            }
        }
    }

    handle.join().unwrap();

    let time_elapsed = pixel_progress.elapsed(); // <2>
    pixel_progress.finish();
    progress_bar.remove(&pixel_progress);
    if let Some(tile_progress) = &tile_progress {
        tile_progress.finish();
        progress_bar.remove(tile_progress)
    }

    // ...
}
```
1. The tiling is not always enabled so we need to wrap it in `Option`. Also, we hope that tile progress is showed over the pixel progress, so if it's used, we add it first.
2. We save the elapsed time before the progress bar is removed, and later we can report it through logger with `indicatif::HumanDuration`.

### Real-time Preview {#sec-p1c5-real-time-preview}