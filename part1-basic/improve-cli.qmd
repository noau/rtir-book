# Improve Cli I {#sec-improve-cli-i}

In this chapter, we'll temporarily move away from the rendering itself, and trying to improve our renderer in some way to make our developing experience better.

::: callout-note
## Language Specific Chapter

This chapter is language specific, which means we spend most time discussing `Rust` and its ecosystem. If you're not using `Rust`, this chapter is still useful, but you need more efforts to achieve the same effects I've done since I use lots of 3rd parties.

You can also skip but it's **not** recommended.
:::

## Improvements

### Cli Parameters {#sec-p1c5-cli-param}

As mentioned earlier in @sec-brute-rendering, we usually use cli parameter to change the behavior of our renderer. Let's first list all possible parameters:

- `tiling`: Use tiled rendering with given tile size.
- `parallel`: A flag enable `rayon`.
- `preview`: Enable real-time preview with `tev` image viewer opened. See @sec-p1c5-real-time-preview.
- `save`: Accepts a path that the rendered result will be save, or don't save if no path is given.

Above are parameters for the renderer.

- `spp`: This should be positive integer, or not presented to use the value defined for the scene.
- `max-ray-depth`: Also positive integer, or not presented to use the value defined for the scene.
- `diable-jittering`: Flag that disable pixel jittering. This means jittering is enabled by default.
- `orthographic`: Flag that enable orthographic projection for the camera. Otherwise projective projection will be used.
- `film-size`: The film size, which is also the output image size.

Above are parameters for to overwrite some parameters in the scene.

- `fast`: A short-hand flag that enables both `parallel` and `tiling`
- `fast-preview`: A short-hand flag that enables `parallel` and `tiling`, and set `spp` to `4`, `max-ray-depth` to `4` to obtains a very fast preview rendering.

Above are shorthands for convience.

All those are parameters for a command called `render`. So you use this cli just like hoe you use `git` - `<renderer-executable> render [parameters...]`. Later we'll add some other commands.

I'm going to use `clap` for cli parameter parsing, since it's powerful and matured.

If you haven't learned about `clap` yet, refer to the book, reference or cookbook of `clap`. What I'm using is called the `derive` api of `clap`, which can generate a argument parser automatically for our parameter definition. The parsed parameter is:

```Rust
#[derive(Parser)]
#[command(version = build::CLAP_LONG_VERSION, about, long_about = None)]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}
```

Note that the `build::CLAP_LONG_VERSION` requires the use of `shadow-rs`. When you use the `--version`(`-v`) option generated by `clap`, this information will be printed out. And the `about` will print out your doc comment for this struct, not just for this, struct, but almost all of them.

The use of `#[command(subcommand)]` means that our cpplication requires a subcommand, which is defined in the `Commands` struct:

```Rust
#[derive(Debug, Subcommand)]
pub enum Commands {
    Render {
        #[arg(
            short, long, name = "TILE_WIDTH,TILE_HEIGHT", value_parser = parse_non_zero_usize_pair // <1>
        )]
        tiling: Option<(usize, usize)>,
        #[arg(
            short, long, name = "FILM_WIDTH,FILM_HEIGHT", value_parser = parse_non_zero_usize_pair
        )]
        film_size: Option<(usize, usize)>,
        #[arg(short, long)]
        parallel: bool,
        #[arg(long)]
        save: Option<Option<PathBuf>>,
        #[arg(long)]
        disable_jittering: Option<bool>,
        #[arg(short, long)]
        orthographic: Option<bool>,
        #[arg(long)]
        preview: bool,
        #[arg(long)]
        spp: Option<NonZeroUsize>,
        #[arg(short = 'd', long)]
        max_ray_depth: Option<NonZeroUsize>,
        #[arg(long)]
        fast: bool,
        #[arg(long)]
        fast_preview: bool,
        sample_scene: SampleScene, // <2>
    },
}

fn parse_non_zero_usize_pair(s: &str) -> Result<(usize, usize), String> {
    let parts: Vec<&str> = s.split(',').collect();
    if parts.len() != 2 {
        return Err("Must be exactly two positive integers.".to_owned());
    }

    let size1 = parts[0]
        .trim()
        .parse::<usize>()
        .map_err(|_| "Must be positive integer.".to_owned())?;
    let size2 = parts[1]
        .trim()
        .parse::<usize>()
        .map_err(|_| "Must be positive integer.".to_owned())?;

    if size1 > 0 && size2 > 0 {
        return Ok((size1, size2));
    }

    Err("Must be positive integer.".to_owned())
}
```
1. The film size and tile size should be two positive integers, like `32,32`, which is a format `clap` doesn't support by default, so we need a custom parser to handle this.
2. Choice of the sample scene is a positional argument instead of an option.

To make things easier, we add a new struct to organize those parameters, and seperate parameters for overwrite scene settings into another struct. Those shorthands are also eliminated.

```Rust
#[derive(Debug, Clone)]
pub struct RenderingConfig {
    pub render_mode: RenderMode,
    pub preview: bool,
    pub test_scene: TestScene,
    pub save: Option<PathBuf>,
    pub scene_config: SceneConfig,
}
```

The conversion between `Commands` and `RenderingConfig` is quite straightforward but verbose, so I am just not showing them.

So now we can extract most part of our `main` to another function that accepts a `RenderingConfig`, instead, the main function parses the cli parameters and start rendering:

```Rust
fn main() {
    // Init the logger for outputs
    env_logger::init();

    let cli = Cli::parse();
    match cli.command {
        r @ Commands::Render { .. } => rendering(r.to_rendering_config()), // <1>
    }
}
```
1. This weird `@` bound value to r if matched.

And the `rendering` function is still similiar, just apply those parameters accordingly. The benefit of seperating parameters for the scene makes it easy to pass them to the scene loader, i.e., currently the `TestScene::build` function.

Try to add more useful argument by your own!

### Progress Report {#sec-p1c5-progress-bar}

### Real-time Preview {#sec-p1c5-real-time-preview}